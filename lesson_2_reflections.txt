When you initialize a repository it means you have added a hidden folder called .git. The . means it is hidden. This then means you are able to begin tracking your repository. But you will need to commit yourself. This will not happen automatically. After you have created git init and initalized git in your repository then you will want to run git status to see that both files are listed as untracked files. 

The working directory is before you have put in your git init, so it is not being tracked. The staging area is the stage before you commit. It allows you greater control and means you can select specific things you would like to commit as opposed to everything inside your directory or repository. The repository is where all your folders are held that are connected by the git init and being tracked. 

You might want to create a branch if you a creating a different version of your master. Such as a version in another language, or you might want to create a new branch if you are experimenting with a different type of code. Branches are helpful because it is clearly labeled alowing you to work on seperate branches with out them effecting one another. Bye labeling the branches clearly you can distingish between linear updates as opposed to creating versions of the master for different purposes. 

The diagrams help me visualise the branch structure because I can trace back the parent of each commit. I am aware that by creating a new branch it or a new comit which is not connected to the main branch will mean it might not have any actual impact on the code. 

By merging two branches together it means that it will use the origional file to select what to keep and what to leave. Because the new branch is now merged and their is a new master branch which combines both commits from each branch. This means that you will be able to see these commits in time order when you do git log. It also means that you no longer need a branch name. Therefore you can delete the branch. This doesn't mean that it gets rid of your commits though, just the label. Now it is merged it is harder to find your parent commits. If you want to look at commits only relevant to your code then you can use git show. 

The pros and ons of of Git's automatic merging vs. always doing merges manually is that sometimes their will be a conflict. This is when the same aspect of a commit has been modified and git is unable to distinguish which should override the other. It will indicate this with a ' and a '' Telling you that you need to decide beetween the two. Git will then indicate in your script with >>>>>>>> HEAD Which will be your script and |||||||| mergered common ancestor which is the origional version and finally ====== >>>>>>>>> master. You need to select the version that you would want to keep or modify it and then delete the version you don't want including all the >>>> ===== headings. You then need to run git status. It shows that both has bee